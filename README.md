# Version 0.04: 

首先要表明的是 **Version 0.04** 是一个里程碑版本。为什么这么说呢？**Version 0.04** 的功能相较于 **Version 0.01** 没有增加，也没有减少。从版本一到版本四仅仅是一步步地对 **Version 0.01** 进行了 C++ 的封装和实现：
- 将 epoll 相关的数据和操作封装进入 Epoll 类中
- 将不断用 epoll_wait 进行轮询的循环操作，以及相关事件发生时的回调操作封装进入 Eventloop 类中，并让 Eventloop 继承 Epoll。之后用到 epollfd 时都只需要传入一个 Eventloop 即可，从而彻底隐藏了 epoll 相关数据和操作
- 将 fd 数据以及对 fd 的操作封装到 Channel 类中
- 设计了两种回调方法，一种是面向连接时回调的，一种是面向读写时回调的，分别对应 Acceptor 类和 Communicator 类
- 设计一个 TcpServer 的类，用来管理 Channel * ，以防内存泄漏，并实现一个 Start 接口让用户来启动服务器。

其实我在一开始的时候并不是能理解为什么要将 **Version 0.01** 慢慢地迭代到  **Version 0.04**。在我看来  **Version 0.01** 更加容易读和理解，而 **Version 0.04** 由于有太多的封装和一层层地调用，以及 C++ 语法糖的介入导致了更加难以阅读和理解（相较于 **Version 0.01**），但是心中又无理由的觉得这种迭代是正确的是必须的。

在看了陈硕大佬的讲解后我终于直到了，这么做有以下几点好处：
1. 原本的代码中，网络编程相关的代码和业务相关的代码高度耦合，这很不利于项目的开发。假如你的团队在开发一个大型项目，团队中有专门写网络编程代码的人和专门写业务相关代码的人，如果将这两部分代码耦合在一起，那么如果这个写业务代码的人对网络编程不熟悉很容易就会引入网络编程方面的 bug，导致开发遇到困难。
2. 将 **Version 0.04** 中的相关数据和操作封装成类，更加容易实现模块化编程，利于项目的迭代和更新，也有利于后期的维护。

从 **Version 0.02** 封装直到  **Version 0.04**，已经彻底地将业务逻辑和网络编程解耦了。所以说这是一个里程碑版本。

因为我设计的是一个简易的网络库。网络库要做的就是产生一个用 TCP 进行通信的一个服务器，接受客户端的连接，接收并解释客户端发过来的数据，将最后解释后的结果呈现给用户，用户可以根据最后的结果来做出相应的 *Response*，并将这个 *Response* 递交给网络库，由网络库安全可靠快速地发送给客户端。

**所以后续版本将设计出一个网络库和用户之间的桥梁。（相较于前四个版本有了新的功能）**

